-- ==============================================================================
-- MASTER RESET SCRIPT (NUCLEAR OPTION V4 - ROBUST)
-- ==============================================================================

-- 1. ROBUST CLEANUP (Handle 'transactions' whether it is a table or view)
DO $$ 
BEGIN 
    -- Try to drop as table first
    DROP TABLE IF EXISTS public.transactions CASCADE; 
EXCEPTION 
    WHEN wrong_object_type THEN 
        -- If it fails because it's a view, drop as view
        DROP VIEW IF EXISTS public.transactions CASCADE; 
END $$;

-- Drop other tables with CASCADE
DROP TABLE IF EXISTS public.purchase_items CASCADE;
DROP TABLE IF EXISTS public.purchases CASCADE;
DROP TABLE IF EXISTS public.sale_items CASCADE;
DROP TABLE IF EXISTS public.sales CASCADE;
DROP TABLE IF EXISTS public.expenses CASCADE;
DROP TABLE IF EXISTS public.expense_categories CASCADE;
DROP TABLE IF EXISTS public.products CASCADE;
DROP TABLE IF EXISTS public.cash_registers CASCADE;
DROP TABLE IF EXISTS public.team_invitations CASCADE;
DROP TABLE IF EXISTS public.team_members CASCADE;
DROP TABLE IF EXISTS public.super_admins CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop Functions
DROP FUNCTION IF EXISTS public.check_is_super_admin CASCADE;
DROP FUNCTION IF EXISTS public.sync_super_admin_from_profile CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user CASCADE;
DROP FUNCTION IF EXISTS public.process_purchase CASCADE;

-- Drop Trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- 2. CREATE TABLES

-- A. PROFILES
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    business_name TEXT,
    address TEXT,
    phone TEXT,
    tax_id TEXT,
    currency TEXT DEFAULT 'USD',
    logo_url TEXT,
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'suspended')),
    is_super_admin BOOLEAN DEFAULT false,
    full_name TEXT,
    email TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- B. SUPER ADMINS
CREATE TABLE public.super_admins (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- C. PRODUCTS
CREATE TABLE public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC NOT NULL DEFAULT 0,
    stock INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- D. SALES & ITEMS
CREATE TABLE public.sales (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    total NUMERIC NOT NULL DEFAULT 0,
    payment_method TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id UUID REFERENCES auth.users(id)
);

CREATE TABLE public.sale_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id BIGINT REFERENCES public.sales(id) ON DELETE CASCADE,
    product_name TEXT NOT NULL,
    qty INTEGER NOT NULL DEFAULT 1,
    price NUMERIC NOT NULL DEFAULT 0
);

-- E. PURCHASES & ITEMS
CREATE TABLE public.purchases (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_name TEXT NOT NULL,
    total NUMERIC NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id UUID REFERENCES auth.users(id)
);

CREATE TABLE public.purchase_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    purchase_id BIGINT REFERENCES public.purchases(id) ON DELETE CASCADE,
    product_id BIGINT REFERENCES public.products(id),
    quantity INTEGER NOT NULL DEFAULT 1,
    cost_price NUMERIC NOT NULL DEFAULT 0
);

-- F. CASH REGISTERS
CREATE TABLE public.cash_registers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    opened_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    closed_at TIMESTAMP WITH TIME ZONE,
    opening_amount NUMERIC NOT NULL DEFAULT 0,
    closing_amount NUMERIC,
    status TEXT DEFAULT 'open' CHECK (status IN ('open', 'closed')),
    opened_by UUID REFERENCES auth.users(id)
);

-- G. EXPENSES
CREATE TABLE public.expense_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE public.expenses (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    amount NUMERIC NOT NULL,
    description TEXT,
    date TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    category_id UUID REFERENCES public.expense_categories(id) ON DELETE SET NULL,
    created_by UUID REFERENCES auth.users(id)
);

-- H. TEAM
CREATE TABLE public.team_members (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    owner_id UUID REFERENCES auth.users(id),
    role TEXT CHECK (role IN ('admin', 'cashier')),
    status TEXT DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE public.team_invitations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    email TEXT NOT NULL,
    owner_id UUID REFERENCES auth.users(id),
    role TEXT CHECK (role IN ('admin', 'cashier')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    status TEXT DEFAULT 'pending'
);

-- 3. CREATE VIEW FOR TRANSACTIONS
CREATE OR REPLACE VIEW public.transactions WITH (security_invoker = on) AS
SELECT
    id::text as id,
    'income' as type,
    total as amount,
    'Venta #' || id as description,
    created_at as date,
    'sale' as reference_type
FROM public.sales
UNION ALL
SELECT
    id::text as id,
    'expense' as type,
    amount,
    description,
    date,
    'expense' as reference_type
FROM public.expenses;


-- 4. FUNCTIONS & TRIGGERS

-- A. Security Check Function
CREATE OR REPLACE FUNCTION public.check_is_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
    -- This runs with owner privileges, bypassing RLS for this specific check
    RETURN EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND is_super_admin = true
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- B. Sync Trigger
CREATE OR REPLACE FUNCTION public.sync_super_admin_from_profile()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.is_super_admin = true THEN
        INSERT INTO public.super_admins (user_id) VALUES (NEW.id) ON CONFLICT DO NOTHING;
    ELSE
        DELETE FROM public.super_admins WHERE user_id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

CREATE TRIGGER on_profile_admin_change
AFTER UPDATE OF is_super_admin OR INSERT ON profiles
FOR EACH ROW EXECUTE FUNCTION public.sync_super_admin_from_profile();

-- C. Auto-create Profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name)
  VALUES (new.id, new.email, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- D. Process Purchase RPC
CREATE OR REPLACE FUNCTION public.process_purchase(p_supplier_name TEXT, p_total NUMERIC, p_items JSONB)
RETURNS VOID AS $$
DECLARE
    v_purchase_id BIGINT;
    v_item JSONB;
BEGIN
    -- Insert Purchase
    INSERT INTO public.purchases (supplier_name, total, user_id)
    VALUES (p_supplier_name, p_total, auth.uid())
    RETURNING id INTO v_purchase_id;

    -- Process Items
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        INSERT INTO public.purchase_items (purchase_id, product_id, quantity, cost_price)
        VALUES (
            v_purchase_id, 
            (v_item->>'product_id')::BIGINT, 
            (v_item->>'quantity')::INTEGER, 
            (v_item->>'cost_price')::NUMERIC
        );
        -- Update Stock
        UPDATE public.products 
        SET stock = stock + (v_item->>'quantity')::INTEGER
        WHERE id = (v_item->>'product_id')::BIGINT;
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;


-- 5. ROW LEVEL SECURITY
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE super_admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales ENABLE ROW LEVEL SECURITY;
ALTER TABLE sale_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE purchase_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE cash_registers ENABLE ROW LEVEL SECURITY;
ALTER TABLE expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE expense_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_invitations ENABLE ROW LEVEL SECURITY;

-- 6. POLICIES

-- Super Admin
CREATE POLICY "Super admins public read" ON super_admins FOR SELECT USING (true);
CREATE POLICY "Super admins service write" ON super_admins FOR ALL USING (auth.role() = 'service_role');

-- PROFILES
-- PROFILES
CREATE POLICY "Profiles view/edit owner or admin" ON profiles
  FOR ALL USING (auth.uid() = id OR check_is_super_admin() = true);

-- Re-create Policy using the Function (Fixing Recursion)
CREATE POLICY "Super Admins can view all profiles" ON profiles
  FOR SELECT USING (
    check_is_super_admin() = true
  );

CREATE POLICY "Super Admins can update any profile" ON profiles
  FOR UPDATE USING (
    check_is_super_admin() = true
  );

CREATE POLICY "Profiles insert self" ON profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

-- PRODUCTS
CREATE POLICY "Products viewable by auth" ON products FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Products managed by admins" ON products FOR ALL USING (check_is_super_admin() = true OR auth.role() = 'authenticated');

-- SALES & ITEMS
CREATE POLICY "Sales managed by auth" ON sales FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Sale items managed by auth" ON sale_items FOR ALL USING (auth.role() = 'authenticated');

-- PURCHASES & ITEMS
CREATE POLICY "Purchases managed by auth" ON purchases FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Purchase items managed by auth" ON purchase_items FOR ALL USING (auth.role() = 'authenticated');

-- EXPENSES
CREATE POLICY "Expenses managed by auth" ON expenses FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Expense Categories managed by auth" ON expense_categories FOR ALL USING (auth.role() = 'authenticated');

-- CASH REGISTERS
CREATE POLICY "Cash registers managed by auth" ON cash_registers FOR ALL USING (auth.role() = 'authenticated');

-- TEAM
CREATE POLICY "Team viewable by involved" ON team_members
  FOR SELECT USING (owner_id = auth.uid() OR user_id = auth.uid() OR check_is_super_admin() = true);
CREATE POLICY "Team managed by owner/admin" ON team_members
  FOR ALL USING (owner_id = auth.uid() OR check_is_super_admin() = true);

-- INVITATIONS
CREATE POLICY "Invitations managed by owner" ON team_invitations
  FOR ALL USING (owner_id = auth.uid() OR check_is_super_admin() = true);

-- 7. SEED DATA
INSERT INTO public.expense_categories (name) VALUES 
('Servicios'), ('Arriendo'), ('NÃ³mina'), ('Inventario'), ('Mantenimiento')
ON CONFLICT DO NOTHING;
